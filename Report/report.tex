\documentclass{article}
\usepackage{fancyhdr}
\usepackage[margin=1in]{geometry}
\usepackage{svg}

\pagestyle{fancy}
\lhead{Pravin Ramana}
\rhead{CS3341 Foundations of Modern Computing Fall 2023}
\renewcommand{\headrulewidth}{0pt}

\begin{document}
\section*{FlowScript DSL and JobSystem Integration Report}
	\subsection{Job System FFI}
		\subsubsection{FFI Communication}
			The FFI utilized by the JobSystem offers communication via JSON objects. The system sends and recieves C-String pointers with data serialized as a JSON. Deserialization then occurs within the JobSystem.
		\subsubsection{JobSystem FFI Features}
			\begin{enumerate}
				\item The ability for other languages to query Job 'handles,' which are descriptors containing information about Job status and allow the calling program to block and wait for jobs to complete, similar to a traditional OS thread handle.
				\item The ability for multiple JobSystems to be created and operated on
				\item Closure-based interface, which allows registerable jobs to adhere to one constraint, which is to consume a JSON and return a JSON.
			\end{enumerate}
	\subsection{FlowScript Design}
		\subsubsection{Design Goal}
			Create a minimal data-oriented language
		\subsection{Syntax}
			\subsubsection{Variables} JSON objects that are only defined during execution) begin with a user-defined name, followed by '{}'. Example: \texttt{foo\{\}}
			\subsubsection{Execution Order and Data Passing} Data may be passed to/from \texttt{Process}es and variables using the \texttt{->} operator. The \texttt{->} assumes the sink is dependent on the source and execution will be order as such to ensure the source has fully completed before passing data to the sink.
			\subsubsection{Conditional Statements} Based on a \texttt{Process}'s output, the flow of execution may be controlled with a condition statement. Condition statements can be invoked by applying \texttt{~} in front of a Process definition, for example: \texttt{~[Process]}. The JSON output of \texttt{Process} must be in the form \texttt{\{"result" : int, "value" : \{...\}\}}. \texttt{result} refers to the index of the branch that should be taken. Given the following FlowScript: \texttt{input{} -> ~[Process] -> ([AnotherProcessA], [AnotherProcessB])}. If the \texttt{result} key was 0, execution would branch to \texttt{AnotherProcessA}, if it was 1, execution would branch to \texttt{AnotherProcessB}. The JSON object within the \texttt{value} is then directly passed to the branched \texttt{Process}. Additionally, a branch can be pointed to with a \texttt{'} referring to an existing or future \texttt{Process}. An example of this would be: \texttt{\{"value": 1\} -> [AddOne]'a -> ~[isGreaterThan10] -> ('a, ReturnValue\{\})}, which will repeatedly branch back to \texttt{AddOne}, until \texttt{isGreaterThan10} returns a \texttt{"result"} of 1.
			\subsection{Parallelism with Fork/Join} Similar to forking on UNIX, fork copies states into separate processes, joining them when they finish. A \texttt{fork} may be performed with the \texttt{<} operator. The forked section will only be completed with a join, with the \texttt{>} operator. An example of this usage for processing in parallel: \texttt{files{} -> <(FileProcessor)> -> outputs}. The fork accepts an array of values and each individual value is passed a separate forked \texttt{Process}. Additionally, another variant of forking with multiple processes in the tuple (...) will use provide each individual index of the input JSON array to their corresponding \texttt{Process}: \texttt{\{[\{"file": \{...\}\}, \{"file": \{...\}\}]\} -> <([ProcessA], [ProcessB])> -> outputs\{\}}.

		\subsection{Translations from FlowScript to DOT}
			\subsubsection{Process execution}
				\begin{enumerate}
					\item \textbf{FlowScript:} \texttt{\{"target" : "test"\} -> make -> clangparse -> contextadd -> output\{\}} \\
					\item \textbf{DOT Code:}
						\begin{verbatim}
							digraph {
							    {
							        node [shape=ellipse]
							        maketarget [data="{\"target\" : \"test\"}"]
							        output
							    }

							    {
							        node [shape=box]
							        make
							        clangparse
							        contextadd
							    }

							    maketarget -> make -> clangparse -> contextadd -> output
							}
						\end{verbatim}
				\end{enumerate}
			\subsection{Conditional Jumping}
				\begin{enumerate}
					\item \textbf{FlowScript:} \texttt{\{"target": "test"\} -> maketarget -> makestatus -> (error\_output\{\}, \\
						clangparse -> parsestatus -> (error\_output\{\}, \\
						contextadd -> contextstatus -> (error\_output\{\}, success\_output\{\}))} \\
					\item \textbf{DOT Code:} \begin{verbatim}
						digraph {
							{
								node [shape=ellipse]
								maketarget [data="{\"target\" : \"test\"}"]
								success_output
								error_output
							}
							{
								node [shape=box]
								make
								clangparse
								contextadd
							}
							{
								node [shape=triangle]
								makestatus 
								parsestatus
								contextstatus
							}
							maketarget -> make -> makestatus -> {error_output, clangparse}
							clangparse -> parsestatus -> {error_output, contextadd}
							contextadd -> contextstatus -> {error_output, success_output}
							}
						\end{verbatim}
				\end{enumerate}
			\subsection{Parallelism}
				Parallelism is achieved in FlowScript via fork/join with trapezium/invtrapezium. Forking to achieve parallelism may be done both explicitly and implicitly. The fork command accepts a data array, which can then be directed to Processes. In the case where only a single process is directed from the work, each process is performed in parallel until it joined. When more than two Processes leave a fork, the data in each index of the data array gets passed to their corresponding job. Example of implicit parallelism: \\
					FlowScript:
					\begin{verbatim}
						{[{"file1": {}}, {"file2": {}}]} -> <fork -> [compile_file] -> join> -> output{}
					\end{verbatim}
					DOT Language:
					\begin{verbatim}
						digraph {
						    {
						        node [shape=ellipse]
						        files
						        output
						    }

						    {
						        node [shape=box]
						        compile_file
						    }
    
						    {
						        node [shape=trapezium]
						        fork_compile
						    }

						    {
						        node [shape=invtrapezium]
						        join_compile
						    }

						    files -> fork_compile -> compile_file -> join_compile -> output
						}
					\end{verbatim}
				An example of explicit parallelism: \\
					FlowScript:
					\begin{verbatim}
						{[{"file1": {}}, {"file2": {}}]} -> <fork -> {[compile_file_1], [compile_file_2]} 
							-> join> -> {output1{}, output2{}}
					\end{verbatim}
					DOT Language:
					\begin{verbatim}
						digraph {
						    {
						        node [shape=ellipse]
						        file1
						        file2
						        output1
						        output2
						    }

						    {
						        node [shape=box]
						        compile_file_1
						        compile_file_2
						    }
    
						    {
						        node [shape=trapezium]
						        fork_compile
						    }

						    {
						        node [shape=invtrapezium]
						        join_compile
						    }

						    {file1, file2} -> fork_compile -> {compile_file_1, compile_file_2} -> join_compile -> {output1, output2}
						}
					\end{verbatim}
\end{document}
